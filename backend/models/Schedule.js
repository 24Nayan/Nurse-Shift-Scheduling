import mongoose from 'mongoose';

const scheduleSchema = new mongoose.Schema({
  // Basic Schedule Information
  ward: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Ward',
    required: [true, 'Ward is required']
  },
  wardName: {
    type: String,
    required: [true, 'Ward name is required'],
    trim: true
  },
  // Multi-ward support for genetic algorithm
  wards: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Ward'
  }],
  wardNames: [String],
  startDate: {
    type: Date,
    required: [true, 'Start date is required']
  },
  endDate: {
    type: Date,
    required: [true, 'End date is required']
  },
  
  // Schedule Data - Core structure for daily assignments
  scheduleData: {
    // Key: date string (YYYY-MM-DD), Value: daily schedule
    type: Map,
    of: {
      shifts: {
        DAY: {
          nurses: [{
            nurseId: { type: mongoose.Schema.Types.ObjectId, ref: 'Nurse', required: true },
            nurseName: { type: String, required: true },
            hours: { type: Number, min: 1, max: 12, default: 8 },
            specialization: String,
            isFloating: { type: Boolean, default: false },
            overtime: { type: Boolean, default: false },
            preference: {
              type: String,
              enum: ['PREFERRED', 'AVAILABLE', 'UNAVAILABLE'],
              default: 'AVAILABLE'
            }
          }],
          requiredNurses: { type: Number, min: 1, default: 1 },
          actualNurses: { type: Number, default: 0 },
          coverage: { type: Number, min: 0, max: 100, default: 0 }
        },
        EVENING: {
          nurses: [{
            nurseId: { type: mongoose.Schema.Types.ObjectId, ref: 'Nurse', required: true },
            nurseName: { type: String, required: true },
            hours: { type: Number, min: 1, max: 12, default: 8 },
            specialization: String,
            isFloating: { type: Boolean, default: false },
            overtime: { type: Boolean, default: false },
            preference: {
              type: String,
              enum: ['PREFERRED', 'AVAILABLE', 'UNAVAILABLE'],
              default: 'AVAILABLE'
            }
          }],
          requiredNurses: { type: Number, min: 1, default: 1 },
          actualNurses: { type: Number, default: 0 },
          coverage: { type: Number, min: 0, max: 100, default: 0 }
        },
        NIGHT: {
          nurses: [{
            nurseId: { type: mongoose.Schema.Types.ObjectId, ref: 'Nurse', required: true },
            nurseName: { type: String, required: true },
            hours: { type: Number, min: 1, max: 12, default: 12 },
            specialization: String,
            isFloating: { type: Boolean, default: false },
            overtime: { type: Boolean, default: false },
            preference: {
              type: String,
              enum: ['PREFERRED', 'AVAILABLE', 'UNAVAILABLE'],
              default: 'AVAILABLE'
            }
          }],
          requiredNurses: { type: Number, min: 1, default: 1 },
          actualNurses: { type: Number, default: 0 },
          coverage: { type: Number, min: 0, max: 100, default: 0 }
        }
      },
      dailyStats: {
        totalNurses: { type: Number, default: 0 },
        totalHours: { type: Number, default: 0 },
        averageCoverage: { type: Number, default: 0 },
        constraintViolations: [{
          type: {
            type: String,
            enum: ['MAX_CONSECUTIVE_NIGHTS', 'MAX_WEEKLY_HOURS', 'MIN_REST_HOURS', 'UNAVAILABLE_ASSIGNMENT']
          },
          nurseId: { type: mongoose.Schema.Types.ObjectId, ref: 'Nurse' },
          nurseName: String,
          description: String,
          severity: {
            type: String,
            enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
            default: 'MEDIUM'
          }
        }]
      }
    }
  },
  
  // Nurse Statistics for the schedule period
  nurseStats: {
    type: Map,
    of: {
      nurseId: { type: mongoose.Schema.Types.ObjectId, ref: 'Nurse' },
      nurseName: String,
      totalHours: { type: Number, default: 0 },
      totalShifts: { type: Number, default: 0 },
      shiftDistribution: {
        DAY: { type: Number, default: 0 },
        EVENING: { type: Number, default: 0 },
        NIGHT: { type: Number, default: 0 }
      },
      consecutiveNights: { type: Number, default: 0 },
      maxConsecutiveNights: { type: Number, default: 0 },
      weeklyHours: { type: Number, default: 0 },
      overtimeHours: { type: Number, default: 0 },
      preferenceSatisfaction: { type: Number, min: 0, max: 100, default: 0 },
      constraintViolations: { type: Number, default: 0 }
    }
  },
  
  // Schedule Status and Management
  status: {
    type: String,
    enum: ['DRAFT', 'PENDING_APPROVAL', 'APPROVED', 'ACTIVE', 'COMPLETED', 'ARCHIVED'],
    default: 'DRAFT'
  },
  generatedAt: {
    type: Date,
    default: Date.now
  },
  generatedBy: {
    type: String,
    required: [true, 'Generated by is required'],
    default: 'system'
  },
  algorithmType: {
    type: String,
    enum: ['GENETIC', 'BASIC', 'CONSTRAINT_SATISFACTION', 'HEURISTIC'],
    default: 'GENETIC'
  },
  
  // Algorithm Configuration and Settings
  generationSettings: {
    useGeneticAlgorithm: { type: Boolean, default: true },
    algorithm: {
      type: String,
      enum: ['GENETIC', 'CONSTRAINT_SATISFACTION', 'HEURISTIC'],
      default: 'GENETIC'
    },
    parameters: {
      populationSize: { type: Number, default: 100 },
      generations: { type: Number, default: 500 },
      mutationRate: { type: Number, default: 0.1 },
      crossoverRate: { type: Number, default: 0.8 },
      elitismRate: { type: Number, default: 0.1 }
    },
    wardCount: { type: Number, default: 1 },
    nurseCount: { type: Number, default: 0 },
    schedulePeriodDays: { type: Number, default: 0 },
    constraints: {
      maxConsecutiveNights: { type: Number, default: 3 },
      maxWeeklyHours: { type: Number, default: 48 },
      minRestHours: { type: Number, default: 11 },
      enforceAvailability: { type: Boolean, default: true },
      allowOvertime: { type: Boolean, default: false },
      preferenceWeight: { type: Number, default: 0.3 }
    },
    objectives: {
      coverageWeight: { type: Number, default: 0.4 },
      fairnessWeight: { type: Number, default: 0.3 },
      preferencesWeight: { type: Number, default: 0.2 },
      constraintsWeight: { type: Number, default: 0.1 }
    }
  },
  
  // Quality Metrics and Performance
  qualityMetrics: {
    overallScore: { type: Number, min: 0, max: 100, default: 0 },
    coverageScore: { type: Number, min: 0, max: 100, default: 0 },
    fairnessScore: { type: Number, min: 0, max: 100, default: 0 },
    preferenceScore: { type: Number, min: 0, max: 100, default: 0 },
    constraintScore: { type: Number, min: 0, max: 100, default: 0 },
    qualificationScore: { type: Number, min: 0, max: 100, default: 0 },
    
    statistics: {
      totalShifts: { type: Number, default: 0 },
      totalHours: { type: Number, default: 0 },
      averageShiftsPerNurse: { type: Number, default: 0 },
      averageHoursPerNurse: { type: Number, default: 0 },
      totalConstraintViolations: { type: Number, default: 0 },
      averageCoverage: { type: Number, default: 0 },
      totalNursesScheduled: { type: Number, default: 0 },
      schedulePeriodDays: { type: Number, default: 0 }
    },
    
    generationTime: { type: Number, default: 0 }, // milliseconds
    algorithmIterations: { type: Number, default: 0 },
    
    // Genetic Algorithm specific metrics
    convergenceHistory: [{
      generation: Number,
      bestFitness: Number,
      avgFitness: Number
    }]
  },
  
  // Version Control and History
  version: {
    type: Number,
    default: 1
  },
  publishedAt: Date,
  publishedBy: String,
  approvedBy: String,
  approvedAt: Date,
  
  // Comments and Notes
  notes: {
    type: String,
    maxlength: [1000, 'Notes cannot exceed 1000 characters'],
    trim: true
  },
  
  // Feedback and Issues
  feedback: [{
    nurseId: { type: mongoose.Schema.Types.ObjectId, ref: 'Nurse' },
    nurseName: String,
    comment: String,
    rating: { 
      type: Number, 
      min: 1, 
      max: 5 
    },
    submittedAt: { type: Date, default: Date.now },
    resolved: { type: Boolean, default: false }
  }],
  
  issues: [{
    type: {
      type: String,
      enum: ['UNDERSTAFFED', 'OVERSTAFFED', 'CONSTRAINT_VIOLATION', 'PREFERENCE_CONFLICT', 'OTHER']
    },
    description: String,
    severity: {
      type: String,
      enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
      default: 'MEDIUM'
    },
    date: String, // Date string for the affected date
    shift: {
      type: String,
      enum: ['DAY', 'EVENING', 'NIGHT']
    },
    resolved: { type: Boolean, default: false },
    reportedAt: { type: Date, default: Date.now }
  }]
}, {
  timestamps: true,
  collection: 'schedules'
});

// Compound indexes for better query performance
scheduleSchema.index({ ward: 1, startDate: 1, endDate: 1 });
scheduleSchema.index({ status: 1, createdAt: -1 });
scheduleSchema.index({ wardName: 1, status: 1 });
scheduleSchema.index({ generatedAt: -1 });

// Instance Methods
scheduleSchema.methods.toSafeObject = function() {
  // Convert Map to plain object for scheduleData
  let scheduleDataObj = {};
  if (this.scheduleData instanceof Map) {
    for (let [key, value] of this.scheduleData.entries()) {
      scheduleDataObj[key] = value;
    }
  } else if (this.scheduleData && typeof this.scheduleData === 'object') {
    scheduleDataObj = this.scheduleData;
  }
  
  // Convert Map to plain object for nurseStats if it exists
  let nurseStatsObj = {};
  if (this.nurseStats instanceof Map) {
    for (let [key, value] of this.nurseStats.entries()) {
      nurseStatsObj[key] = value;
    }
  } else if (this.nurseStats && typeof this.nurseStats === 'object') {
    nurseStatsObj = this.nurseStats;
  }

  return {
    _id: this._id,
    ward: this.ward,
    wardName: this.wardName,
    startDate: this.startDate,
    endDate: this.endDate,
    scheduleData: scheduleDataObj,
    nurseStats: nurseStatsObj,
    status: this.status,
    generatedAt: this.generatedAt,
    generatedBy: this.generatedBy,
    generationSettings: this.generationSettings,
    qualityMetrics: this.qualityMetrics,
    version: this.version,
    publishedAt: this.publishedAt,
    publishedBy: this.publishedBy,
    approvedBy: this.approvedBy,
    approvedAt: this.approvedAt,
    notes: this.notes,
    feedback: this.feedback,
    issues: this.issues,
    createdAt: this.createdAt,
    updatedAt: this.updatedAt
  };
};

scheduleSchema.methods.approve = function(approvedBy) {
  this.status = 'APPROVED';
  this.approvedBy = approvedBy;
  this.approvedAt = new Date();
  return this.save();
};

scheduleSchema.methods.publish = function(publishedBy) {
  this.status = 'ACTIVE';
  this.publishedBy = publishedBy;
  this.publishedAt = new Date();
  return this.save();
};

scheduleSchema.methods.archive = function() {
  this.status = 'ARCHIVED';
  return this.save();
};

// Method to get assignments for a specific nurse
scheduleSchema.methods.getAssignmentsForNurse = function(nurseId) {
  const nurseAssignments = {};
  
  console.log(`\n=== getAssignmentsForNurse called ===`);
  console.log(`Nurse ID: ${nurseId} (type: ${nurseId?.constructor?.name})`);
  console.log(`Schedule ID: ${this._id}`);
  console.log(`scheduleData exists: ${!!this.scheduleData}`);
  console.log(`scheduleData type: ${this.scheduleData?.constructor?.name || typeof this.scheduleData}`);
  console.log(`scheduleData size/length: ${this.scheduleData instanceof Map ? this.scheduleData.size : this.scheduleData ? (Array.isArray(this.scheduleData) ? this.scheduleData.length : Object.keys(this.scheduleData).length) : 0}`);
  
  if (!this.scheduleData) {
    console.log(`getAssignmentsForNurse: No scheduleData for nurse ${nurseId}`);
    return nurseAssignments;
  }
  
  if ((this.scheduleData instanceof Map && this.scheduleData.size === 0) || 
      (typeof this.scheduleData === 'object' && !Array.isArray(this.scheduleData) && Object.keys(this.scheduleData).length === 0) ||
      (Array.isArray(this.scheduleData) && this.scheduleData.length === 0)) {
    console.log(`getAssignmentsForNurse: Empty scheduleData for nurse ${nurseId}`);
    return nurseAssignments;
  }
  
  // Normalize nurseId to string for comparison
  const targetNurseIdStr = nurseId.toString();
  
  // Convert Map to entries for iteration
  let scheduleEntries;
  if (this.scheduleData instanceof Map) {
    scheduleEntries = Array.from(this.scheduleData.entries());
    console.log(`scheduleData is a Map with ${scheduleEntries.length} entries`);
  } else if (Array.isArray(this.scheduleData)) {
    // If it's an array, convert it to key-value pairs (assuming it's an array of [key, value] tuples or array of objects)
    console.log(`WARNING: scheduleData is an array, not a Map! Converting...`);
    scheduleEntries = this.scheduleData.map((item, idx) => {
      if (Array.isArray(item) && item.length >= 2) {
        return [item[0], item[1]];
      } else if (typeof item === 'object' && item.date) {
        return [item.date, item];
      } else {
        return [`date_${idx}`, item];
      }
    });
  } else {
    scheduleEntries = Object.entries(this.scheduleData);
    console.log(`scheduleData is a plain object with ${scheduleEntries.length} entries`);
  }
  
  console.log(`getAssignmentsForNurse: Checking ${scheduleEntries.length} days for nurse ${targetNurseIdStr}`);
  
  for (const [dateKey, dayData] of scheduleEntries) {
    if (!dayData || !dayData.shifts) {
      continue;
    }
    
    const shifts = {};
    
    // Check each shift type
    ['DAY', 'EVENING', 'NIGHT'].forEach(shiftType => {
      const shiftData = dayData.shifts[shiftType];
      if (!shiftData || !shiftData.nurses || !Array.isArray(shiftData.nurses)) {
        return;
      }
      
      // Find nurse assignment - handle both ObjectId and string nurseId
      const assignment = shiftData.nurses.find(nurse => {
        if (!nurse || !nurse.nurseId) return false;
        
        // Normalize nurseId to string
        const nurseIdStr = typeof nurse.nurseId === 'object' && nurse.nurseId.toString ? 
          nurse.nurseId.toString() : 
          String(nurse.nurseId);
        
        return nurseIdStr === targetNurseIdStr;
      });
      
      if (assignment) {
        shifts[shiftType] = assignment;
        console.log(`Found ${shiftType} assignment for nurse ${targetNurseIdStr} on ${dateKey}`);
        console.log(`  Assignment object keys:`, Object.keys(assignment));
        console.log(`  Assignment has nurses array?:`, Array.isArray(assignment.nurses));
        // Verify assignment is not the full shiftData object
        if (Array.isArray(assignment.nurses)) {
          console.log(`  ERROR: Assignment object contains nurses array! This should be the individual assignment only.`);
        }
      }
    });
    
    if (Object.keys(shifts).length > 0) {
      nurseAssignments[dateKey] = {
        date: dayData.date || dateKey,
        shifts
      };
    }
  }
  
  console.log(`getAssignmentsForNurse: Returning ${Object.keys(nurseAssignments).length} days with assignments for nurse ${targetNurseIdStr}`);
  
  return nurseAssignments;
};

// Static Methods
scheduleSchema.statics.findActiveSchedules = function(wardId) {
  return this.find({ 
    ward: wardId, 
    status: 'ACTIVE' 
  }).sort({ startDate: -1 });
};

scheduleSchema.statics.findByWard = function(wardId, limit = 10) {
  return this.find({ ward: wardId })
    .populate('ward', 'name department')
    .sort({ startDate: -1 })
    .limit(limit);
};

export default mongoose.model('Schedule', scheduleSchema);